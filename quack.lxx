%top{
/* Quack scanner
 *
 * 2018 Fall version for RE/flex,
 * skeleton. 
 * 
 */ 

#include "quack.tab.hxx"  /* Generated by bison. */
#include "Messages.h"
%}

%{
/* Externally visible file name --
* for error messages.
* FIXME: Need to extract this from structures that reflex passes
* or else find another way to dig it out.
*/
std::string yyfilename = "What file is this, anyway?";

/* Some strings can't be matched in one gulp.  We need
 * a buffer in which to assemble them from parts.
 */
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

/* Some long messages that don't fit well in the code below */

std::string BAD_ESC_MSG =
  "Illegal escape code; only \\\\, \\0, \\t, \\n, \\r, \\n are permitted";
std::string BAD_NL_STR =
  "Unclosed string?  Encountered newline in quoted string."; 

%}


%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

  /* You'll probably want scanner states for both multi-line
   * comments and for triple-quote strings.  Do comments first,
   * because they're easier (you just throw away the text).  Then
   * do triple-quote strings.  You might consider doing the same for
   * normal strings with a single pair of double quotes, to avoid
   * writing a really ugly regex.  'comment' here is an example of
   * how to declare an exclusive scanner state. 
   */ 
%x comment
%x quote
%x triplequote

%%


[/]{2}.*                 { /* Single-line comments */ }

  /* We start with some tokens that are not value-bearing,
   * i.e., the parser needs to know only which token was matched.
   */

  /* Multi-character punctuation with names */
==    { return parser::token::EQUALS; }
[<]=  { return parser::token::ATMOST; }
[>]=  { return parser::token::ATLEAST; }


   /* Single character punctuation.  Because a character
    * in C or C++ can be treated as an integer, Bison lets
    * us return a character as a token.
    * JFlex/Cup do not let you do this in Java.
    * Here are a few ... there are more. 
    */

[-+*/\(\)\{\}=,;.:<>]   { return text()[0]; }

  /* Keywords are essentially another kind of punctuation,
   * but since they also match the identifier pattern, we
   * need to be sure we give their patterns *before* the
   * identifier pattern.  Most scanner generators work this
   * way, but WARNING for Python PLY users:  PLY prioritizes
   * by length of the regular expression!
   * Here are a couple of examples. 
   */

class     { return parser::token::CLASS; }
def       { return parser::token::DEF; }
extends   { return parser::token::EXTENDS; }
if        { return parser::token::IF; }
elif      { return parser::token::ELIF; }
else      { return parser::token::ELSE; }
while     { return parser::token::WHILE; }
return    { return parser::token::RETURN; }
typecase  { return parser::token::TYPECASE; }
and       { return parser::token::AND; }
or        { return parser::token::OR; }
not       { return parser::token::NOT; }


   /* The following tokens are value-bearing:
    * We pass a value back to the parser by copying
    * it into the yylval parameter.  The parser
    * expects string values for identifiers and
    * string literals in yylval.str.  It expects integer
    * values for integer literals in yylval.num.
    * I'll give pattern for integer literals.
    * You'll need another for identifiers.  Remember to
    * 'strdup' the value returned by 'text()', or else it will
    * be clobbered by subsequent calls. 
    */

[0-9]+                                  { yylval.num = atoi(text()); return parser::token::INT_LIT; }
[a-zA-Z_][a-zA-Z0-9_]*                  { yylval.str = strdup(text()); return parser::token::IDENT; }

["]{3}                                  { start(triplequote); }
<triplequote>["]{3}                     { start(INITIAL); return parser::token::STRING_LIT; }
<triplequote><<EOF>>                    { report::error("Non-terminated string '" + std::string(yylval.str) + "' at line " + std::to_string(lineno()) + ", column " + std::to_string(columno())); start(INITIAL); }
/* Within a triple-quote, match any character other than 3 consecutive quotes, including newlines */
<triplequote>([^"]|[\r\n]|["]{1,2}[^"])*  { yylval.str = strdup(text()); } 


["]                                     { string_buf = ""; start(quote); }
<quote>["]                              { yylval.str = strdup(string_buf.c_str()); start(INITIAL); return parser::token::STRING_LIT; }
<quote>[\\]0                            { string_buf += "\0"; }
<quote>[\\]b                            { string_buf += "\b"; }
<quote>[\\]t                            { string_buf += "\t"; }
<quote>[\\]n                            { string_buf += "\n"; }
<quote>[\\]r                            { string_buf += "\r"; }
<quote>[\\]f                            { string_buf += "\f"; }
<quote>[\\]["]                          { string_buf += "\""; }
<quote>[\\]{2}                          { string_buf += "\\"; }
<quote>[\\](.|[\r\n])                   { report::error("Illegal escape sequence '" + std::string(text()) + "'"+
                                                        " at line " + std::to_string(lineno()) +
                                                        ", column " + std::to_string(columno())); }
<quote>[\r\n]                           { report::error("Unexpected newline or end of string at line " + std::to_string(lineno()) +
                                                        ", column " + std::to_string(columno())); 
                                                        yylval.str = strdup(string_buf.c_str()); 
                                                        start(INITIAL); 
                                                        return parser::token::STRING_LIT; }
<quote>[^\r\n"\\]*                      { string_buf += std::string(text()); }

  /* You *can* write a one-line regular expression for matching a quoted string,
   * but you probably can't read it.  (I can't read mine.)  Scanner states and
   * simpler patterns are probably a better idea.
   * You almost certainly scanner states for triple quotes.
   * The tricky bit is catching errors, such as disallowed escape sequences
   * and unclosed quotes.
   */ 

  /* Ignore whitespace */
[ \t\n]*  { ; }

   /* Multi-line comments */ 
[/][*]  { start(comment); }
<comment>[^*]*   { ; }
<comment>[*][^/] { ; }
<comment>[*][/]  { start(INITIAL); }

.  {   report::error("Unexpected character '" + std::string(text()) + "'" +
       " at line " + std::to_string(lineno()) +
       ", column " + std::to_string(columno()));
   }

<<EOF>>  { return EOF; }

%%

/* No main program here */ 

