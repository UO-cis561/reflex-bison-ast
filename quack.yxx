/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }
}


%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
}
%union {
    int   num;
    char* str;
}

// The following token values are actually used
%token <str> IDENT STRING_LIT
%token <num> INT_LIT
// The following tokens don't need values
%token CLASS DEF EXTENDS RETURN TYPECASE
%token EQUALS ATMOST ATLEAST AND OR NOT
%token IF ELIF ELSE WHILE
// Abstract syntax tree nodes
/*%type <node> program opt_classes classes class class_sig class_body opt_args opt_extends args arg extends opt_statements opt_methods statements statement methods method opt_type if_block r_expr opt_elifs elifs opt_else l_expr opt_r_expr
*/
%left AND OR NOT
%left EQUALS ATMOST '<' ATLEAST '>'
%left '-' '+'
%left '*' '/'
%left '.'

%error-verbose

%%

program: opt_classes opt_statements {}

opt_classes: classes {}
           |         {}

classes: class         {}
       | classes class {}

class: class_sig class_body {}

class_sig: CLASS IDENT '(' opt_args ')' opt_extends {}

opt_args: args {}
        |      {}

args: arg      {}
    | args ',' arg {}

arg: IDENT ':' IDENT {}

opt_extends: extends {}
           |         {}

extends: EXTENDS IDENT {}

class_body: '{' opt_statements opt_methods '}' {}

opt_statements: statements {}
              |            {}

statements: statement            {}
          | statements statement {}

statement: if_block                            {}
         | WHILE r_expr '{' opt_statements '}' {}
         | l_expr opt_type '=' r_expr ';'      {}
         | r_expr ';'                          {}
         | RETURN opt_r_expr ';'               {}
         | typecase                            {}

opt_methods: methods {}
           |         {}

methods: method         {}
       | methods method {}

method: DEF IDENT '(' opt_args ')' opt_type '{' opt_statements '}' {}

opt_type: ':' IDENT {}
        |           {}

if_block: IF r_expr '{' opt_statements '}' opt_elifs opt_else {}

opt_elifs: elifs {}
         |       {}

elifs: elif       {}
     | elifs elif {}

elif: ELIF r_expr '{' opt_statements '}' {}

opt_else: else {}
        |      {}

else: ELSE '{' opt_statements '}' {}

opt_r_expr: r_expr {}
          |        {} 

r_expr: STRING_LIT            {}
      | INT_LIT               {}
      | l_expr                {}
      | '(' r_expr ')'        {}
      | r_expr '+' r_expr     {}
      | r_expr '-' r_expr     {}
      | r_expr '*' r_expr     {}
      | r_expr '/' r_expr     {}
      | r_expr EQUALS r_expr  {}
      | r_expr ATMOST r_expr  {}
      | r_expr '<' r_expr     {}
      | r_expr ATLEAST r_expr {}
      | r_expr '>' r_expr     {}
      | r_expr AND r_expr     {}
      | r_expr OR r_expr      {}
      | NOT r_expr            {}
      | '-' r_expr            {}
      | IDENT '(' opt_actual_args ')' { /* Constructor call */ }
      | r_expr '.' IDENT '(' opt_actual_args ')' {}

opt_actual_args: actual_args {}
               |             {}

actual_args: r_expr                 {}
           | actual_args ',' r_expr {}


l_expr: IDENT            {}
      | r_expr '.' IDENT {}

typecase: TYPECASE r_expr '{' type_alternatives '}' {}

type_alternatives: type_alternative                   {}
                 | type_alternatives type_alternative {}

type_alternative: IDENT ':' IDENT '{' opt_statements '}' {}

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

