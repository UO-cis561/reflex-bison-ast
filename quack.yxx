/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "AST.h"
}


%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode **root }

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
}
%union {
    int          num;
    char         *str;
    AST::Block   *block;
    AST::Class   *clazz;
    AST::Ident   *ident;
    AST::Arg     *arg;
    AST::Leaf    *leaf;
}

// The following token values are actually used
%token <str> IDENT STRING_LIT
%token <num> INT_LIT
// The following tokens don't need values
%token CLASS DEF EXTENDS RETURN TYPECASE
%token EQUALS ATMOST ATLEAST AND OR NOT
%token IF ELIF ELSE WHILE
// Abstract syntax tree nodes
%type <block> program opt_classes classes opt_args args
%type <clazz> class
%type <ident> opt_extends extends
%type <arg> arg
%type <leaf> opt_statements
%left AND OR NOT
%left EQUALS ATMOST '<' ATLEAST '>'
%left '-' '+'
%left '*' '/'
%left '.'

%error-verbose

%%

program: opt_classes opt_statements { 
    $$ = new AST::Block(); 
    $$->append($1); 
    $$->append($2); 
    *root = $$; 
}

opt_classes: classes { $$ = $1; }
           |         { $$ = new AST::Block(); }

classes: class         { $$ = new AST::Block(); $$->append($1); }
       | classes class { $$ = $1; $$->append($2); }

class: CLASS IDENT '(' opt_args ')' opt_extends '{' opt_statements opt_methods '}' { $$ = new AST::Class(new AST::Ident($2), $4, $6); }

opt_args: args { $$ = $1; }
        |      { $$ = new AST::Block(); }

args: arg          { $$ = new AST::Block(); $$->append($1); }
    | args ',' arg { $$ = $1; $$->append($3); }

arg: IDENT ':' IDENT { $$ = new AST::Arg(new AST::Ident($1), new AST::Ident($3)); }

opt_extends: extends { $$ = $1; }
           |         { $$ = new AST::Ident(""); }

extends: EXTENDS IDENT { $$ = new AST::Ident($2); }

opt_statements: statements { $$ = new AST::Leaf("Statements"); }
              |            { $$ = new AST::Leaf("Statements"); }

statements: statement            {}
          | statements statement {}

statement: if_block                            {}
         | WHILE r_expr '{' opt_statements '}' {}
         | l_expr opt_type '=' r_expr ';'      {}
         | r_expr ';'                          {}
         | RETURN opt_r_expr ';'               {}
         | typecase                            {}

opt_methods: methods {}
           |         {}

methods: method         {}
       | methods method {}

method: DEF IDENT '(' opt_args ')' opt_type '{' opt_statements '}' {}

opt_type: ':' IDENT {}
        |           {}

if_block: IF r_expr '{' opt_statements '}' opt_elifs opt_else {}

opt_elifs: elifs {}
         |       {}

elifs: elif       {}
     | elifs elif {}

elif: ELIF r_expr '{' opt_statements '}' {}

opt_else: else {}
        |      {}

else: ELSE '{' opt_statements '}' {}

opt_r_expr: r_expr {}
          |        {} 

r_expr: STRING_LIT            {}
      | INT_LIT               {}
      | l_expr                {}
      | '(' r_expr ')'        {}
      | r_expr '+' r_expr     {}
      | r_expr '-' r_expr     {}
      | r_expr '*' r_expr     {}
      | r_expr '/' r_expr     {}
      | r_expr EQUALS r_expr  {}
      | r_expr ATMOST r_expr  {}
      | r_expr '<' r_expr     {}
      | r_expr ATLEAST r_expr {}
      | r_expr '>' r_expr     {}
      | r_expr AND r_expr     {}
      | r_expr OR r_expr      {}
      | NOT r_expr            {}
      | '-' r_expr            {}
      | IDENT '(' opt_actual_args ')' { /* Constructor call */ }
      | r_expr '.' IDENT '(' opt_actual_args ')' {}

opt_actual_args: actual_args {}
               |             {}

actual_args: r_expr                 {}
           | actual_args ',' r_expr {}


l_expr: IDENT            {}
      | r_expr '.' IDENT {}

typecase: TYPECASE r_expr '{' type_alternatives '}' {}

type_alternatives: type_alternative                   {}
                 | type_alternatives type_alternative {}

type_alternative: IDENT ':' IDENT '{' opt_statements '}' {}

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

