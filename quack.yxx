/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "AST.h"
}


%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::Root **root }

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
}
%union {
    int            num;
    char           *str;
    AST::Statement *stmt;
    AST::Block     *block;
    AST::Class     *clazz;
    AST::Ident     *ident;
    AST::Actuals   *actuals;
    AST::Arguments *args;
    AST::Arg       *arg;
    AST::LExpr     *lexpr;
    AST::RExpr     *rexpr;
    AST::Method    *method;
    AST::If        *ifblock;
    AST::TypeAlt   *typealt;
    AST::Typecase  *typecase;
    std::vector<AST::If*> *elifs;
    std::vector<AST::TypeAlt*> *typealts;
}

// The following token values are actually used
%token <str> IDENT STRING_LIT
%token <num> INT_LIT
// The following tokens don't need values
%token CLASS DEF EXTENDS RETURN TYPECASE
%token EQUALS ATMOST ATLEAST AND OR NOT
%token IF ELIF ELSE WHILE
// Abstract syntax tree nodes
%type <block> opt_classes classes opt_statements statements opt_methods methods opt_else else
%type <actuals> opt_args args
%type <clazz> class
%type <ident> opt_extends extends opt_type
%type <arg> arg
%type <lexpr> l_expr
%type <rexpr> r_expr opt_r_expr
%type <method> method
%type <ifblock> if_block elif
%type <elifs> elifs opt_elifs
%type <args> opt_actual_args actual_args
%type <typealts> type_alternatives
%type <typealt> type_alternative
%type <typecase> typecase
%type <stmt> statement
%left AND OR NOT
%left EQUALS ATMOST '<' ATLEAST '>'
%left '-' '+'
%left '*' '/'
%left '.'

%error-verbose

%%

program: opt_classes opt_statements { 
    *root = new AST::Root($1, $2); 
}

opt_classes: classes { $$ = $1; }
           |         { $$ = new AST::Block(); }

classes: class         { $$ = new AST::Block(); $$->append($1); }
       | classes class { $$ = $1; $$->append($2); }

class: CLASS IDENT '(' opt_args ')' opt_extends '{' opt_statements opt_methods '}' { $$ = new AST::Class(new AST::Ident($2), $4, $6, $8, $9); }

opt_args: args { $$ = $1; }
        |      { $$ = new AST::Actuals(); }

args: arg          { $$ = new AST::Actuals(); $$->append($1); }
    | args ',' arg { $$ = $1; $$->append($3); }

arg: IDENT ':' IDENT { $$ = new AST::Arg(new AST::Ident($1), new AST::Ident($3)); }

opt_extends: extends { $$ = $1; }
           |         { $$ = new AST::Ident("Obj"); }

extends: EXTENDS IDENT { $$ = new AST::Ident($2); }

opt_statements: statements { $$ = $1; }
              |            { $$ = new AST::Block(); }

statements: statement            { $$ = new AST::Block(); $$->append($1); }
          | statements statement { $$ = $1; $$->append($2); }

statement: if_block                            { $$ = $1; }
         | WHILE r_expr '{' opt_statements '}' { $$ = new AST::While($2, $4); }
         | l_expr opt_type '=' r_expr ';'      { $$ = new AST::Assignment($1, $2, $4); }
         | r_expr ';'                          { $$ = $1; }
         | RETURN opt_r_expr ';'               { $$ = new AST::Return($2); }
         | typecase                            { $$ = $1; }

opt_methods: methods { $$ = $1; }
           |         { $$ = new AST::Block(); }

methods: method         { $$ = new AST::Block(); $$->append($1); }
       | methods method { $$ = $1; $$->append($2); }

method: DEF IDENT '(' opt_args ')' opt_type '{' opt_statements '}' { $$ = new AST::Method(new AST::Ident($2), $4, $6, $8); }

opt_type: ':' IDENT { $$ = new AST::Ident($2); }
        |           { $$ = NULL; }

if_block: IF r_expr '{' opt_statements '}' opt_elifs opt_else   { 
                                                                    $$ = new AST::If($2, $4, NULL); 
                                                                    AST::If *curr = $$;
                                                                    for (AST::If *elif: *$6) {
                                                                        AST::Block *new_else = new AST::Block();
                                                                        new_else->append(elif);
                                                                        curr->set_else(new_else);
                                                                        curr = elif;
                                                                    }
                                                                    curr->set_else($7);
                                                                    delete $6;
                                                                }

opt_elifs: elifs { $$ = $1;}
         |       { $$ = new std::vector<AST::If*>(); }

elifs: elif       { $$ = new std::vector<AST::If*>(); $$->push_back($1); }
     | elifs elif { $$ = $1; $$->push_back($2); }

elif: ELIF r_expr '{' opt_statements '}' { $$ = new AST::If($2, $4, NULL); }

opt_else: else { $$ = $1; }
        |      { $$ = new AST::Block(); }

else: ELSE '{' opt_statements '}' { $$ = $3; }

opt_r_expr: r_expr { $$ = $1; }
          |        { $$ = NULL;} 

r_expr: STRING_LIT            { $$ = new AST::StrLit($1); }
      | INT_LIT               { $$ = new AST::IntLit($1); }
      | l_expr                { $$ = $1; }
      | '(' r_expr ')'        { $$ = $2; }
      | r_expr '+' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("PLUS"),    args); }
      | r_expr '-' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("MINUS"),   args); }
      | r_expr '*' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("TIMES"),   args); }
      | r_expr '/' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("DIVIDE"),  args); }
      | r_expr EQUALS r_expr  { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("EQUALS"),  args); }
      | r_expr ATMOST r_expr  { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("ATMOST"),  args); }
      | r_expr '<' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("LESS"),    args); }
      | r_expr ATLEAST r_expr { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("ATLEAST"), args); }
      | r_expr '>' r_expr     { AST::Arguments *args = new AST::Arguments(); args->append($3); $$ = new AST::Call($1, new AST::Ident("MORE"),    args); }
      | r_expr AND r_expr     { $$ = new AST::And($1, $3); }
      | r_expr OR r_expr      { $$ = new AST::Or($1, $3); }
      | NOT r_expr            { $$ = new AST::Not($2); }
      | '-' r_expr            { $$ = new AST::Call($2, new AST::Ident("MINUS"), new AST::Arguments()); }
      | IDENT '(' opt_actual_args ')' { $$ = new AST::Constructor(new AST::Ident($1), $3); }
      | r_expr '.' IDENT '(' opt_actual_args ')' { $$ = new AST::Call($1, new AST::Ident($3), $5); }

opt_actual_args: actual_args { $$ = $1; }
               |             { $$ = new AST::Arguments(); }

actual_args: r_expr                 { $$ = new AST::Arguments(); $$->append($1); }
           | actual_args ',' r_expr { $$ = $1; $$->append($3); }


l_expr: IDENT            { $$ = new AST::LExpr(new AST::Ident($1)); }
      | r_expr '.' IDENT { $$ = new AST::LExpr($1, new AST::Ident($3)); }

typecase: TYPECASE r_expr '{' type_alternatives '}' { 
                                                        $$ = new AST::Typecase($2); 
                                                        for (AST::TypeAlt *alt: *$4) {
                                                            $$->append(alt);
                                                        }
                                                        delete $4;
                                                    }

type_alternatives: type_alternative                   { $$ = new std::vector<AST::TypeAlt*>(); $$->push_back($1); }
                 | type_alternatives type_alternative { $$ = $1; $$->push_back($2); }

type_alternative: IDENT ':' IDENT '{' opt_statements '}' { $$ = new AST::TypeAlt(new AST::Arg(new AST::Ident($1), new AST::Ident($3)), $5); }

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

