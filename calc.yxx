/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
    // block needs a more explicit type to use the 'append' method
    AST::Block* block;
}

// The following token values are actually used
%token <str> IDENT
%token <num> NUMBER
// The following tokens don't need values
%token PLUS  MINUS TIMES DIV GETS
%token IF THEN ELSE FI ELIF
%token LPAREN RPAREN

// Abstract syntax tree nodes
%type <node> expr leaf program stmt assignment
%type <block> block if_alternatives
%type <node> ifstmt

// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
%left MINUS PLUS
%left TIMES DIV

%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: block  { *root = $1; } ;

/* Standard recursive definition for a non-empty sequence. */
block: block stmt { $1->append($2); $$ = $1; }
     | stmt       { $$ = new AST::Block(); $$->append($1); }
     ;


stmt: assignment { $$ = $1; }
    | expr { $$ = $1; }
    | ifstmt { $$ = $1; }
    ;

ifstmt:  IF expr THEN block if_alternatives FI
 {    $$ = new AST::If(*$2, *$4, *$5);  } ;

if_alternatives:   /* empty */  { $$ = new AST::Block(); };
if_alternatives:   ELSE block   { $$ = $2; };
if_alternatives:   ELIF expr THEN block if_alternatives
 {  $$ = new AST::Block();
    $$->append(new AST::If(*$2, *$4, *$5));
 };



assignment: IDENT GETS expr {
        AST::Ident* lhs = new AST::Ident($1);
        AST::ASTNode*  rhs =  $3;
        $$ = new AST::Assign(*lhs, *rhs);
        };

expr : expr PLUS expr  { $$ = new AST::Plus( *$1, *$3 ); dump($$); }
     | expr MINUS expr { $$ = new AST::Minus( *$1, *$3 ); dump($$); }
     | expr TIMES expr { $$ = new AST::Times( *$1, *$3 ); dump($$); }
     | expr DIV expr   { $$ = new AST::Div( *$1, *$3 ); dump($$); }
     | LPAREN expr RPAREN { $$ = $2; }
     | leaf            { $$ = $1; }
     | error  leaf     { $$ = $2; }
     ;

leaf : IDENT  { $$ = new AST::Ident( std::string($1)); dump($$); }
     | NUMBER { $$ = new AST::IntConst( $1 );  dump($$); }
     ;


%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
