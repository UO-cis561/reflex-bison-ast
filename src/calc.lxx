/* Scanner for "C" assignment statements... sort of. */
/* Compile: reflex --bison-cc --bison-locations --header-file reflexexample9.lxx */
/* Compile: bison -d flexexample9.yxx */

%top{
#include "calc.tab.hxx"  /* Generated by bison. */
#include "Messages.h"
%}

%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

%%
   /* Punctuation and keywords don't need values. */

\+  {  return yy::parser::token::PLUS; }
\*  {  return yy::parser::token::TIMES; }
\-  {  return yy::parser::token::MINUS; }
\/  {  return yy::parser::token::DIV; }

\(  {  return yy::parser::token::LPAREN; }
\)  {   return yy::parser::token::RPAREN; }

  /* Boolean-valued expressions */
<  {   return yy::parser::token::LESS; }
>  {   return yy::parser::token::GREATER; }
>= {   return yy::parser::token::ATLEAST; }
<= {   return yy::parser::token::ATMOST; }
== {   return yy::parser::token::EQUALS; }

    /* Keywords for if/then/elif/else/fi construct */

if   {  return yy::parser::token::IF; }
then   {  return yy::parser::token::THEN; }
else   {  return yy::parser::token::ELSE; }
elif   {  return yy::parser::token::ELIF; }
fi     {  return yy::parser::token::FI; }

    /* Boolean connectives */
and     { return yy::parser::token::AND; }
or      { return yy::parser::token::OR;  }
not     { return yy::parser::token::NOT; }

 /* Integer literals and identifiers do need semantic values,
  * the integer value or the identifier text.
  */

[[:digit:]]+  { yylval.num = atoi(text());   return yy::parser::token::NUMBER; }
[[:alnum:]_]+  { yylval.str = strdup(text()); return yy::parser::token::IDENT; }



=   { yylval.str = strdup(text()); return yy::parser::token::GETS; }
[ \n]          {}
.  {
    report::error("Unexpected character '" + std::string(text()) + "'" +
       " at line " + std::to_string(lineno()) +
       ", column " + std::to_string(columno()));
   }

%%

